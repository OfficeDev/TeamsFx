// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";

import * as dotenv from "dotenv";
import fs from "fs-extra";
import * as path from "path";
import * as os from "os";
import { TelemetryHelper } from "./utils/telemetry-helper";
import { TelemetryEvent } from "./constants";
import { Utils } from "./utils";

export interface RemoteEnvs {
  teamsfxRemoteEnvs: { [key: string]: string };
  customizedRemoteEnvs: { [name: string]: string };
}

export const envFileName = (envName: string): string => `env.teamsfx.${envName}`;
export const envFilePath = (envName: string, folder: string): string =>
  path.join(folder, envFileName(envName));

export const EnvKeys = Object.freeze({
  FuncEndpoint: "REACT_APP_FUNC_ENDPOINT",
  FuncName: "REACT_APP_FUNC_NAME",
  RuntimeEndpoint: "REACT_APP_TEAMSFX_ENDPOINT",
  StartLoginPage: "REACT_APP_START_LOGIN_PAGE_URL",
  ClientID: "REACT_APP_CLIENT_ID",
});

export const getEmptyEnvs = (): RemoteEnvs => {
  return {
    teamsfxRemoteEnvs: {},
    customizedRemoteEnvs: {},
  };
};

export async function loadEnvFile(envPath: string): Promise<RemoteEnvs> {
  if (!(await fs.pathExists(envPath))) {
    return getEmptyEnvs();
  }
  const envs = dotenv.parse(await fs.readFile(envPath));
  const result = getEmptyEnvs();
  const entries = Object.entries(envs);
  for (const [key, value] of entries) {
    if (Object.values(EnvKeys).includes(key)) {
      result.teamsfxRemoteEnvs[key] = value;
    } else {
      result.customizedRemoteEnvs[key] = value;
    }
  }
  return result;
}

export async function saveEnvFile(envPath: string, envs: RemoteEnvs): Promise<void> {
  try {
    const configs = await loadEnvFile(envPath);
    const newConfigs: RemoteEnvs = {
      teamsfxRemoteEnvs: { ...configs.teamsfxRemoteEnvs, ...envs.teamsfxRemoteEnvs },
      customizedRemoteEnvs: { ...configs.customizedRemoteEnvs, ...envs.customizedRemoteEnvs },
    };

    if (
      Utils.isKvPairEqual(newConfigs.customizedRemoteEnvs, configs.customizedRemoteEnvs) &&
      Utils.isKvPairEqual(newConfigs.teamsfxRemoteEnvs, configs.teamsfxRemoteEnvs)
    ) {
      // Avoid updating dotenv file's modified time if nothing changes.
      // We decide whether to skip deployment by comparing the mtime of all project files and last deployment time.
      return;
    }

    await fs.ensureFile(envPath);

    const envString =
      `# Following variables are generated by TeamsFx${os.EOL}` +
      concatEnvString(newConfigs.teamsfxRemoteEnvs) +
      `${os.EOL}# Following variables can be customized or you can add your owns${os.EOL}` +
      `# FOO=BAR${os.EOL}` +
      concatEnvString(newConfigs.customizedRemoteEnvs);

    await fs.writeFile(envPath, envString);
  } catch (error) {
    // For now, it is ok if save env file failed.
    TelemetryHelper.sendErrorEvent(TelemetryEvent.SaveEnvFile, error);
  }
}

function concatEnvString(envs: { [key: string]: string }): string {
  return (
    Object.entries(envs)
      .map(([k, v]) => `${k}=${v}`)
      .join(os.EOL) + os.EOL
  );
}
