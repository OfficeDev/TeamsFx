// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import { Result } from "neverthrow";
import {
  EnvMeta,
  FunctionRouter,
  FxError,
  QTreeNode,
  TokenProvider,
  Void,
  Func,
  Json,
} from "../index";
import { AppStudioTokenProvider, AzureAccountProvider } from "../utils";
import { Context, Inputs, Stage } from "./types";

type ResourceTemplate = BicepTemplate | JsonTemplate;

type JsonTemplate = {
  kind: "json";
  template: Json;
};

type BicepTemplate = {
  kind: "bicep";
  template: Record<string, unknown>;
  parameters: Json;
};

export interface ResourceProvisionContext extends Context {
  envMeta: EnvMeta;

  solutionConfig: Json;
  resourceConfig: Json;
}

export type ResourceDeployContext = ResourceProvisionContext;

export interface ResourceConfigureContext extends ResourceProvisionContext {
  deploymentConfigs: Json;
  provisionConfigs: Record<string, Json>;
}

export interface ResourcePublishContext extends Context {
  envMeta: EnvMeta;
  tokenProvider: TokenProvider;
  manifest: Json;
}

export interface ResourceProvisionResult {
  resourceValues: Record<string, string>;
  stateValues: Record<string, string>;
  secretValues: Record<string, string>;
}

export interface ResourceDeploymentResult {
  stateValues: Record<string, string>;
  secretValues: Record<string, string>;
}

type ProvisionConfig = Json;

/**
 * Interface for ResourcePlugins. a ResourcePlugin can hook into Toolkit's
 * lifecycles by implementing the corresponding API.
 * All lifecycles follows the same pattern of returning a Promise<Result<T, FxError>>.
 *
 * Please prefer to return {@link UserError} or {@link SystemError} when error happens
 * instead of throwing.
 *
 */
export interface ResourcePlugin {
  // Name used by the toolkit to uniquely identify this plugin.
  name: string;

  // Plugin name that will be shown to end users.
  displayName: string;

  /**
   * Scaffold source code on disk, relative to context.projectPath
   * @example
   * Here's a simple example
   * ```
   * const fs = require("fs-extra");
   * let content = "let x = 1;"
   * let path = path.join(ctx.projectPath, "myFolder");
   * let sourcePath = "somePathhere";
   * let result = await fs.copy(sourcePath, content);
   * ```
   *
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {Inputs} inputs - User answers to quesions defined in {@link getQuestionsForLifecycleTask}
   * for {@link Stage.create} along with some system inputs.
   *
   * @returns Void because side effect is expected.
   */
  scaffoldSourceCode?: (ctx: Context, inputs: Inputs) => Promise<Result<Void, FxError>>;

  /**
   * Called when creating a new project or a new environment.
   * Returns resource templates (e.g. Bicep templates/plain JSON) for provisioning.
   *
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {Inputs} inputs - User's answers to quesions defined in {@link getQuestionsForLifecycleTask}
   * for {@link Stage.create} along with some system inputs.
   *
   * @return ResourceTemplate for provisioning and deployment.
   */
  generateResourceTemplate?: (
    ctx: Context,
    inputs: Inputs
  ) => Promise<Result<ResourceTemplate, FxError>>;

  /**
   * Toolkit will replace the place holders with user-supplied env config values and pass the complete
   * provisionTemplate as parameter.
   * Plugins are expected to submit the provisionTemplate to Azure using token provided by {@link TokenProvider}.
   * Plugins can also do custom operations like accessing AppStudio using {@link TokenProvider},
   * or use Azure SDK to change cloud settings.
   *
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {Json} provisionTemplate - a complete provision template with all placeholders replaced by user-supplied env values.
   * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
   *
   * @returns the config, project state, secrect values for the current environment. Toolkit will persist them
   *          and use them to generate complete deployment template.
   */
  provisionResource?: (
    ctx: Context,
    provisionTemplate: Json,
    tokenProvider: TokenProvider
  ) => Promise<Result<ResourceProvisionResult, FxError>>;

  /**
   * configureResource is previously named postProvision, and is used to resolve cross-plugin config dependencies.
   * It will run right after {@link provisionResource}.
   * Plugins are expected to read the provision output values of other plugins, and return a new copy of provisionValues,
   * possibly with added fields.
   *
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {Json} provisionTemplate - values generated by {@link provisionResource}
   * @param {Record<string, Json>} provisionValuesOfOtherPlugins - values of other plugins generated by {@link provisionResource}
   * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
   *
   * @returns a new copy of provisionValues possibly with added fields. Toolkit will persist it for you.
   *
   */
  configureResource?: (
    ctx: Context,
    provisionValues: Json,
    provisionValuesOfOtherPlugins: Record<string, Json>,
    tokenProvider: TokenProvider
  ) => Promise<Result<ProvisionConfig, FxError>>;

  /**
   * Generates a Teams manifest package for the current project,
   * and stores on disk
   *
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {Inputs} inputs - User answers to quesions defined in {@link getQuestionsForLifecycleTask}
   * for {@link Stage.package} along with some system inputs.
   *
   * @returns Void because side effect is expected.
   */
  package?: (ctx: Context, inputs: Inputs) => Promise<Result<Void, FxError>>;

  /**
   * Depends on the values returned by {@link provisionResource} and {@link configureResource}.
   * Toolkit will replace the placeholders with provisionValues values and pass the complete
   * deployTemplate as parameter.
   * Plugins are expected to submit the deployTemplate to Azure.
   *
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {Json} provisionTemplate - a complete provision template with all placeholders replaced by user-supplied env values.
   * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
   *
   * @returns ResourceDeployment results. Plugins can't generate new values in this lifecycle, only states and secrets.
   */
  deploy?: (
    ctx: Context,
    deployTemplate: Json,
    tokenProvider: AzureAccountProvider
  ) => Promise<Result<ResourceDeployContext, FxError>>;

  /**
   * Depends on the output of {@link package}. Uploads Teams package to AppStudio
   * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
   * @param {AppStudioTokenProvider} tokenProvider - Token for AppStudio
   * @param {Inputs} inputs - User answers to quesions defined in {@link getQuestionsForLifecycleTask}
   * for {@link Stage.publish} along with some system inputs.
   *
   * @returns Void because side effect is expected.
   */
  publishApplication?: (
    ctx: Context,
    manifest: Json,
    tokenProvider: AppStudioTokenProvider,
    inputs: Inputs
  ) => Promise<Result<Void, FxError>>;

  getQuestionsForLifecycleTask?: (
    ctx: Context,
    stage: Stage,
    inputs: Inputs
  ) => Promise<Result<QTreeNode | undefined, FxError>>;

  getQuestionsForUserTask?: (
    ctx: Context,
    router: FunctionRouter,
    inputs: Inputs
  ) => Promise<Result<QTreeNode | undefined, FxError>>;

  // Building teams package is now defined as a user task
  executeUserTask?: (ctx: Context, func: Func, inputs: Inputs) => Promise<Result<unknown, FxError>>;
}
